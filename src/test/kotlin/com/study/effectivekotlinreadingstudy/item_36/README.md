# Item 36. 상속보다는 컴포지션을 사용하라

- - -

* 상속은 'is-a' 관계의 계층 구조를 만들기 위해 설계되었다.
* 상속은 관계가 명확하지 않을 때, 단순하게 코드 추출 또는 재사용을 위해 상속을 하려고 한다면 조금 더 신중히 생각해야 한다.
* 일반적으로 상속보다는 컴포지션이 더 좋다.

### 간단한 행위 재사용
* 상속은 하나의 클래스만을 대상으로 할 수 있고, 상속을 통해 행위를 추출하다 보면, 많은 함수를 갖는 BaseXXX 클래스를 만들게 되고, 굉장히 깊고 복잡한 계층 구조가 만들어질 수 있다.
* 상속은 클래스의 모든 것을 가져오게 하므로, 불필요한 함수를 갖는 클래스가 만들어질 수 있다. 이는 인터페이스 분리 원칙(Interface Segregation Principle)을 위반한다.
* 상속은 이해하기 어렵다. 메서드를 읽고, 메서드의 동작 방식을 이해하기 위해 슈퍼클래스를 여러 번 확인해야 한다면 문제가 있는 것이다.
  * 컴포지션을 사용하면 코드를 읽는 사람들이 코드의 실행을 더 명확하게 알 수 있다.
* 컴포지션을 활용하면 하나의 클래스 내부에서 여러 기능을 재사용할 수 있다.

### 모든 것을 가져올 수밖에 없는 상속
* 상속은 슈퍼클래스의 메서드, 제약, 행위 등 모든 것을 가져온다.
  * 일부분을 재사용하기 위한 목적으로 적합하지 않다.
  * 컴포지션은 우리가 원하는 기능만을 가져올 수 있게 한다.

### 캡슐화를 깨는 상속
* 상속은 내부적인 구현 방법 변경에 의해 클래스의 캡슐화가 깨질 수 있다.
* 상속된 메서드를 직접 활용하는 것이 위험할 때는 위임 패턴을 사용하는 것이 좋다.
  * 코틀린은 by 키워드를 통해 포워딩 메서드를 손쉽게 구현할 수 있다.

### 오버라이딩 제한하기
* 상속용으로 설계되지 않은 클래스는 상속하지 못하게 final 키워드를 사용하면 된다.
  * 특정한 이유로 상속은 하지만, 메서드는 오버라이드하지 못하게 만들고 싶은 경우에는 메서드에 open 키워드를 사용한다.
  * open 클래스는 open 메서드만 오버라이드 할 수 있다.
  * 메서드를 오버라이드할 때, 서브클래스에서 해당 메서드에 final을 붙일 수도 있다.
