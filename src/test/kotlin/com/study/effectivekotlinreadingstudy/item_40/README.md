# Item 40. equals의 규약을 지켜라

- - -

* 코틀린의 Any에는 다음과 같이 잘 설정된 규약들을 가진 메서드들이 있다.
  * equals
  * hashCode
  * toString

### 동등성
* 구조적 동등성 (structural equality): equals 메서드와 이를 기반으로 만들어진 == 연산자(!= 포함)로 확인하는 동등성이다.
  * a가 nullable이 아니라면 a == b는 a.equals(b)로 변환되고, a가 nullable이라면 a?.equals(b) ?: (b === null)로 변환된다.
* 레퍼런스적 동등성(referential equality): === 연산자(!== 포함)로 확인하는 동등성이다.
  * 두 피연산자가 같은 객체를 가리키면, true를 리턴한다.

### equals가 필요한 이유
* Any 클래스에 구현되어 있는 equals 메서드는 디폴트로 === 처럼 두 인스턴스가 완전히 같은 객체인지를 비교한다.
* 두 객체가 기본 생성자의 프로퍼티가 같다면, 같은 객체로 보는 형태의 동등성을 표현해야할 때가 있다.
  * data 한정자를 붙여서 데이터 클래스로 정의하면 자동으로 이와 같은 동등성으로 동작한다.
  * 데이터 클래스는 내부에 어떤 값을 갖고 있는지가 중요하므로, 이와 같이 동작하는 것이 좋다.
  * 때문에 일반적으로 데이터 모델을 표현할 때는 data 한정자를 붙인다.
  * 이러한 data 한정자의 equals 지원 덕분에 코틀린에서는 equals를 직접 구현할 필요가 없다. (상황에 따라 구현해야 하는 경우가 있을 수도 있다.)
* equals를 직접 구현해야하는 경우
  * 기본적으로 제공되는 동작과 다른 동작을 해야 하는 경우
  * 일부 프로퍼티만으로 비교해야 하는 경우
  * data 한정자를 붙이는 것을 원하지 않거나, 비교해야 하는 프로퍼티가 기본 생성자에 없는 경우

### equals의 규약
* 반사적(reflexive) 동작: x가 null이 아닌 값이라면, x.equals(x) true를 리턴해야 한다.
* 대칭적(symmetric) 동작: x와 y가 null이 아닌 값이라면, x.equals(y)는 x.equals(x)와 같은 결과를 출력해야 한다.
* 연속적(transitive) 동작: x, y, z가 null이 아닌 값이고, x.equals(y)와 y.equals(z)가 true라면, x.equals(z)도 true여야 한다.
* 일관적(consistent) 동작: x와 y가 null이 아닌 값이라면, x.equals(y)는 여러 번 실행하더라도 항상 같은 결과를 리턴해야 한다.
* null과 관련된 동작: x가 null이 아닌 값이라면, x.equals(null)은 항상 false를 리턴해야 한다.

### equals 구현하기
* 특별한 이유가 없는 이상, 직접 equals를 구현하는 것은 좋지 않다.
* 기본적으로 제공되는 것을 그대로 쓰거나, 데이터 클래스로 만들어서 사용하는 것이 좋다. 그래도 구현해야 한다면, 반사적, 대칭적, 연속적, 일관적 동작 규칙을 꼭 준수하자.
  * 그리고 이러한 클래스는 final로 만드는 것이 좋다. 만약 상속을 한다면, 서브클래스에서 equals가 작동하는 방식을 변경하면 안된다는 것을 주의해야 한다.
  * 상속을 지원하면서 완벽한 사용자 정의 equals 함수를 만드는 것은 거의 불가능에 가깝다.
* data 클래스는 언제나 final이다.