# Item 45. 불필요한 객체 생성을 피하라

- - -

* 객체 생성은 비용이 들어가고, 상황에 따라 굉장히 큰 비용이 들어갈 수 있으므로 불필요한 객체 생성은 최적화의 관점에서 좋다.
  * 예를 들어, JVM에서는 하나의 가상 머신에서 동일한 문자열을 처리하는 코드가 여러 개 있다면, 기존의 문자열을 재사용한다.
  * Integer와 Long처럼 박싱된 기본 자료형도 작은 경우에는 재사용된다. (기본적으로 Int는 -128 ~ 127 범위를 캐싱해 둔다.)
  * -128~127 범위를 벗어나는 숫자는 캐시되지 않는다.
  * nullable 타입은 int 자료형 대신 Integer 자료형을 사용하게 강제된다.
  * Int를 사용하면, 일반적으로 기본 자료형 int로 컴파일 되지만, nullable로 만들거나, 타입 아규먼트로 사용할 경우에는 Integer로 컴파일도니다. 기본 자료형은 null일 수 업속, 타입 아규먼트로도 사용할 수 없기 때문이다.

### 객체 생성 비용은 항상 클까?
* 어떤 객체를 랩(wrap)하면, 크게 세 가지 비용이 발생한다.
  * 객체는 더 많은 용량을 차지한다. 현대 64비트 JDK에서 객체는 8바이트의 배수만큼 공간을 차지한다. 앞부분 12바이트는 헤더로 반드시 있어야 하므로, 최소 크기는 16바이트이다. (32비트 JVM에서는 8바이트이다.)
    * 객체에 대한 레퍼런스도 공간을 차지한다. 일반적으로 레퍼런스는 -Xmx32G까지는 32비트 플랫폼과 64비트 플랫폼 모두 4바이트이다.
    * 64비트 플랫폼에서 32G(-Xmx32G)부터는 8바이트이다.
    * 기본 자료형 int는 4바이트지만, 64비트 JDK에 랩(wrap)되어 있는 Integer는 16바이트이다. 추가로 이에 대한 레퍼런스로 인해 8바이트가 더 필요하다.
  * 요소가 캡슐화되어 있다면, 접근에 추가적인 함수 호출이 필요하다.
  * 객체는 생성되어야 한다.
    * 객체는 생성되고, 메모리 영역에 할당되고, 이에 대한 레퍼런스를 만드는 작업이 필요하다.
* 객체를 제거함으로써 이런 세 가지 비용을 모두 피할 수 있다.
* 객체를 재사용하면 첫 번째오 ㅏ세 번째에 설명한 비용을 제거할 수 있다.

### 객체 선언
* 매 순간 객체를 생성하지 않고, 객체를 재사용하는 간단한 방법은 싱글톤을 사용하는 것이다.

### 캐시를 활용하는 팩토리 함수
* 일반적으로 객체는 생성자를 사용해서 만들지만, 팩토리 메서드를 사용해서 만드는 경우도 있다.
* 팩토리 함수는 캐시를 가질 수 있다.
* 팩토리 함수는 항상 같은 객체를 리턴하게 만들 수도 있다.
* parameterized 팩토리 메서드도 캐싱을 활용할 수 있다. 예를 들어 객체를 다음과 같이 map에 저장해둘 수 있다.
```kotlin
private val connections = mutableMapOf<String, Connection>()

fun getConnection(host: String) = connections.getOrPut(host) { createConnection(host) }
```
* 모든 순수 함수는 캐싱을 활용할 수 있다. 이를 메모이제이션(memoization)이라고 부른다.
```kotlin
private val FIB_CACHE = mutableMapOf<Int, BigInteger>()

fun fib(n: Int): BigInteger = FIB_CACHE.getOrPut(n) {
    if (n <= 1) BigInteger.ONE else fib(n - 1) + fib(n - 1)
}
```
* 다만 캐시를 위한 Map을 저장해야 하므로, 더 많은 메모리를 사용한다.
  * 메모리 문제로 크래시가 생긴다면 메모리를 해제해 주면 된다. 메모리가 필요할 때 GC가 자동으로 메모리를 해제해 주는 SoftReference를 사용하면 더욱 좋다.
  
### WeakReference와 SoftReference의 차이
* WeakReference
  * GC가 값을 정리(clean)하는 것을 막지 않는다. 따라서 다른 레퍼런스가 이를 사용하지 않으면 곧바로 제거된다.
* SoftReference
  * GC가 값을 정리할 수도 있고, 정리하지 않을 수도 있다.
  * 일반적인 JVM 구현의 경우, 메모리가 부족해서 추가로 필요한 경우에만 정리한다.
  * 따라서 캐시를 만들 때는 SoftReference를 사용하는 것이 좋다.

### 무거운 객체를 외부 스코프로 보내기
* 컬렉션 처리에서 이루어지는 무거운 연산은 컬렉션 처리 함수 내부에서 외부로 빼는 것이 좋다.

### 지연 초기화
* 무거운 클래스를 만들 때는 지연되게 만드는 것이 좋을 때가 있다.
* 지연 초기화는 가벼운 객체를 빠르게 만들고, 실제 필요할 때 무거운 객체를 생성할 수 있다는 장점이 있지만 단점도 있다.
  * 무거운 객체를 가졌지만, 메서드의 호출은 빨라야 하는 경우가 있을 수 있다. 처음 호출될 때 무거운 객체들의 초기화가 필요하여 응답시간이 길어질 수 있다.
  * 지연되게 만들면, 성능 테스트가 복잡해지는 문제가 있다.

### 기본 자료형 사용하기
* JVM은 숫자와 문자 등의 기본적인 요소를 나타내기 위한 특별한 기본 내장 자료형을 갖고 있다. 이를 기본 자료형(primitives)이라고 부른다.
* 코틀린/JVM 컴파일러는 내부적으로 최대한 이러한 기본 자료형을 사용한다.
* 다음의 경우에는 기본 자료형을 랩(wrap)한 자료형이 사용된다.
  * nullable 타입을 연산할 때(기본 자료형은 null일 수 없으므로)
  * 타입을 제네릭으로 사용할 때

