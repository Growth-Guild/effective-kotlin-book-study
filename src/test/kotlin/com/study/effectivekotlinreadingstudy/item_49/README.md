# Item 49. 하나 이상의 처리 단계를 가진 경우에는 시퀀스를 사용하라

- - -

* Iterable과 Sequence는 완전히 다른 목적으로 설계되었다.
* Sequence는 지연(lazy) 처리된다.
  * 시퀀스 처리 함수들을 사용하면, 데코레이터 패턴으로 꾸며진 새로운 시퀀스가 리턴된다.
  * 최종적인 계산은 toList 또는 count 등의 최종 연산이 이루어질 때 수행된다.
* Iterable은 처리 함수를 사용할 때마다 연산이 이루어져 List가 만들어진다.

### 시퀀스의 지연 처리 장점
* 자연스러운 처리 순서를 유지한다
* 최소한만 연산한다.
* 무한 시퀀스 형태로 사용할 수 있다.
* 각각의 단계에서 컬렉션을 만들어 내지 않는다.

### 순서의 중요성
* 시퀀스 처리는 요소 하나하나에 지정한 연산을 한꺼번에 적용한다. 이를 element-by-element order 또는 lazy order라고 부른다.
* 이터러블은 요소 천제를 대상으로 연산을 차근차근 적용해 나간다. 이를 step-by-step order 또는 eager order 라고 부른다.

### 최소 연산
* 컬렉션에서 어떤 처리를 적용하고, 앞의 요소 10개만 필요한 상황에서 시퀀스를 활용하면 효율적인 처리가 가능하다.
  * 이터러블은 중간 연산의 개념이 없으므로, 원하는 처리를 전체 요소에 적용한 뒤, 앞의 요소 10개를 사용해야 한다.
  * 시퀀스는 중간 연산이 있으므로, 앞의 요소 10개에만 원하는 처리를 적용할 수 있다.

### 무한 시퀀스
* 시퀀스는 실제로 최종 연산이 일어나기 전까지는 컬렉션에 어떠한 처리도 하지 않는다.
* 따라서 무한 시퀀스를 만들고, 필요한 부분까지만 값을 추출하는 것도 가능하다.
* 무한 시퀀스를 만드는 일반적인 방법은 generateSequence 또는 sequence를 사용하는 것이다.
* generateSequence는 '첫 번째 요소'와 '그 다음 요소를 계산하는 방법'을 지정해야 한다.
```kotlin
generateSequence(1) { it + 1 }
  .map { it * 2 }
  .take(10)
  .forEach { println("$it, ") }
```
* sequence는 중단 함수(suspending function)로 요소들을 지정한다.
* sequence 빌더는 중단 함수 내부에서 yield로 값을 하나씩 만들어낸다.
* 시퀀스는 종결 연산으로 끝내지 않으면 무한 반복에 빠질 수 있으므로 주의한다.

### 각각의 단계에서 컬렉션을 만들어 내지 않음
* 표준 컬렉션 처리 함수는 각각의 단계에서 새로운 컬렉션을 만들어 낸다.
  * 일반적으로 대부분 List이다.
  * 각각의 단계에서 만들어진 결과를 활용하거나 저장할 수 있다는 것은 컬렉션의 장점이지만, 각각의 단계에서 결과가 만들어지면서 차지하는 비용이 든다는 것은 단점이다.
```kotlin
numbers
  .filter { it % 10 == 0 }  // 여기서 컬렉션 하나
  .map { it * 2 }   // 여기서 컬렉션 하나
  .sum()
// 전체적으로 2개의 컬렉션이 만들어진다.

numbers
  .asSequence()
  .filter { it % 30 == 0 }
  .map { it * 2 }
  .sum()
// 컬렉션이 만들어지지 않는다.
```

### 시퀀스가 빠르지 않은 경우
* 컬렉션 전체를 기반으로 처리해야 하는 연산은 시퀀스를 사용해도 빨라지지 않는다.
* 예시로 코틀린의 stdlib의 sorted가 있다.
  * sorted는 Sequence를 List로 변환한 뒤에, 자바 stdlib의 sort를 사용해 처리한다. 이러한 변환 처리로 인해 시퀀스가 컬렉션 처리보다 느려진다.
* 무한 시퀀스처럼 시퀀스의 다음 요소를 lazy하게 구하는 시퀀스에 sorted를 적용하면 무한 반복에 빠지는 문제가 있다. 무한 시퀀스에 sorted는 사용할 수 없다는 결함은 따로 기억해 두는 것이 좋다.
```kotlin
generateSequence(0) { it + 1 }.take(10).sorted().toList()
// [0, 1, 2, 3, 4, 5, 6, 7, 8,9]
generateSequence(0) { it + 1 }.sorted().take(10).toList()
// 종료되지 않는다. 어떤 값도 리턴하지 않는다.
```

### 자바 스트림의 경우
* 자바 8의 스트림도 lazy하게 작동하며, 마지막 처리 단계에서 연산이 일어난다.
* 다만 자바의 스트림과 코틀린의 시퀀스는 다음과 같은 세 가지 큰 차이점이 있다.
  * 코틀린의 시퀀스가 더 많은 처리 함수를 갖고 있다. 그리고 사용하기 더 쉽다.
  * 자바 스트림은 병렬 함수를 사용해서 병렬 모드로 실행할 수 있다. 이는 멀티 코어 환경에서 큰 성능 향상을 가져온다.
  * 코틀린의 시퀀스는 코틀린/JVM, 코틀린/JS, 코틀린/네이티브 등의 일반적인 모듈에서 모두 사용할 수 있다.
* 일반저그올 병렬 모드를 사용하지 않는다면, 자바 스트림과 코틀린 시퀀스 중에 어떤 것이 더 효율적이라고 단정지어서 이야기하기 어렵다.

### 코틀린 시퀀스 디버깅
* 코틀린 시퀀스와 자바 스트림은 모두 단계적으로 요소의 흐름을 추적할 수 있는 디버깅 기능이 지원된다.
* 자바 스트림은 'Java Stream Debugger', 코틀린은 'Kotlin Sequence Debugger'라는 이름의 플러그인으로 활용할 수 있다.
